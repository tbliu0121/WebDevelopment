# webpack性能优化
* 开发环境性能优化
* 生产环境性能优化

## 开发环境性能优化
* **优化打包构建速度**
  * **HMR**：在开发环境下使用HMR功能可以使构建速度更快。HTML只有一个，因此不需要处理，CSS经过了style-loader也是处理好了的；JS是默认不支持HMR的，需要我们自己配置。
* **优化代码调试**
  * **source-map**:  目的是优化代码调试；注意不同值的含义。提供了一种源代码和构建后的代码之间的映射关系。内联模式一般用于开发环境；hidden和nosources用于生产环境下的代码隐藏。推荐：开发模式下使用eval-source-map / eval-cheap-module-source-map;  生产环境下使用source-map / cheap-module-source-map。

## 生产环境性能优化
* 目的：让将来上线的代码能达到最好，让用户的体验好。

* **优化打包构建速度**（提升开发者的体验）

  * **oneOf:** 遇到满足条件的loader之后就停止loader的遍历；（切记，如果一个文件需要多个loader处理，不可以放在同一oneOf里面）。
  * **babel缓存**
    * 代码中的js代码是最多的，babel-loader需要对js代码转化，开启babel缓存有利于代码转化速度。
  * **多进程打包**：  当某个任务耗时很长时，可以开启多进程打包（多进程打包的开启需要时间，600ms左右），因此一定要让任务时间大于多进程打包开启时间。
  * **externals**:   让某些库不被打包；完全不被打包，通过CDN直接引入。
  * **dll**:  将某些库单独打包出来，后期使用直接引入即可；可以在后期打包的时候只打包自己的文件。dll打包的资源变动的时候，运行webpack.dll.js配置即可。dll需要在webpack.dll.js和webpack.config.js分别配置。dll可以和code-split技术结合使用。
  * 【注】从代码层面来看，项目的代码分为两部分：node_modules第三方库和自己开发的源代码。源代码可以通过import进行任意拆分，而optimization只能将node_modules整体拆分，此时通过dll可以将目标库任意拆分（牛啤.jpg）。

* **优化代码运行的性能**（让构建大代码的性能更加高效）

  * **资源缓存**：hash / chunkhash / contenthash。通过为资源添加hash值来完成资源在强缓存期间变动可重新请求资源的目的。

    * hash: 每次打包之后内容不论是否变化，hash都会变化。
    * chunkhash: 同一个打包入口文件的hash都是一样的。
    * contenthash: 根据文件的内容来生成hash值。
  * **tree-shaking**:  将引用代码但是未使用的代码清理掉。只要在生产环境下使用了es6模块化才可以自动开启tree-shaking优化（通过一个uglify-js）还需要在package.json中配置sideEffects将不想删除的代码配置进去。
  * **code-split:**  三种情况，一般使用的时候只有两种。单入口场景；多入口场景。
    * 单入口情况下默认只有一个bundle，因此需要对代码分割，从而可以并行加载文件；单入口文件有两种分割方式：
      * 通过webpack的optimization配置，将node_modules文件单独打包。
      * 通过ES10的import语法对文件单独分割。
    * 多入口文件的分割：通过optimization将多个文件的公共依赖提取出来，避免对共工依赖的重复打包。同时多入口文件也可以使用import语法。
    * [注]： 代码分割只是大致分割，dll和externals是更为细致的分割。
  * **懒加载和预加载**： JS代码的懒加载；通过代码分割，将需要懒加载的代码的加载触发条件放入到异步回调函数当中。预加载则是在浏览器加载完当前资源之后对后续的资源进行加载。理论上预加载要比懒加载好，但是预加载存在很大的兼容性问题，需要慎重使用。（can i use~）
  * **PWA**：  渐进式网络开发应用程序，一种离线可访问技术。由service-worker和cache组成。同样存在兼容性问题和缓存配置的问题。